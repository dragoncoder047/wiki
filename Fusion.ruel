@NUTSHELL Fusion

Fusion is a rule I devised that is a 'fusion' of many different wire-like rules. It steals properties from:
* Wireworld++ => tiny AND/XOR gates
* NoTimeAtAll (Moore neighborhood variant) => stagnating signals
* Digital => diagonal inputs, orthogonal outputs
* DECA => tiny AND/ANDNOT gates

States:

0: {B} background
1: {SH} strong head
2: {ST} strong tail
3: {SW} strong wire
4: {WH} weak head
5: {WT} weak tail
6: {WW} weak wire
7: {NH1} NTAA head 1
8: {NH0} NTAA head 0
9: {NT} NTAA tail
10: {NW} NTAA wire

neighbors, me = n[:-1], n[-1]
orthneighbors = neighbors[4:8]
diagneighbors = neighbors[0:4]
counts = [0] * 11
orthcounts = [0] * 11
diagcounts = [0] * 11
for i in neighbors:
    counts[i] += 1
for i in orthneighbors:
    orthcounts[i] += 1
for i in diagneighbors:
    diagcounts[i] += 1

if me == 0: return 0 # background

elif me == 1: return 2 # strong head
elif me == 2: return 3 # strong tail
elif me == 3: # strong wire
    if (counts[7] + counts[8] == 1) and (counts[3] + counts[6] in (1, 2)):
        return 1 if counts[7] == 1 else 2 # change to head or tail if transition from NTAA
    if counts[1] not in (1, 2) and counts[4] != 2: return 3 # wouldn't turn on anyway
    if has_orth_seq(neighbors, [[3, 6], 7, [1, 4], 0]): return 6 # blocked by NTAA cell
    return 1 # yay, can turn on
elif me == 4: return 5 # weak head
elif me == 5: return 6 # weak tail
elif me == 6: # weak wire
    if (counts[7] + counts[8] == 1) and (counts[3] + counts[6] in (1, 2)):
        return 4 if counts[7] == 1 else 5 # change to head or tail if transition from NTAA
    if counts[1] != 1 and counts[4] not in (1, 2): return 6 # wouldn't turn on anyway
    if has_orth_seq(neighbors, [[3, 6], 7, [1, 4], 0]): return 6 # blocked by NTAA cell
    return 4 # yay, can turn on
elif me == 7 or me == 8: # NTAA head 1 or 0
    if has_any(neighbors, [7, 8, 9, 10]): # behave as wire
        if (has_any(neighbors, [7, 8]) and has_any(neighbors, [9])) or not has_any(neighbors, [10]):
            return 9 # change to tail
        return me # stay the same
    else: # behave as DECA blocker cell
        # swap state if has orth 2, 3, 5
        if has_any(orthneighbors, [2, 3, 5]):
            return 7 if me == 8 else 8
        return me
elif me == 9: # NTAA tail
    if not (has_any(neighbors, [9]) and has_any(neighbors, [10])):
        return me
    return 10 # stay the same
elif me == 10: # NTAA wire
    if not has_any(neighbors, [7, 8, 9, 10]): return 8 # make sure something bad doesn't happen: DECA cell
    if has_orth_seq(neighbors, [0, 0, [2, 5, 9], 0]): return 10 # can only turn on if not next to tail
    if sum(orthcounts[i] for i in (2, 3, 5, 6, 9, 10)) == 1 and sum(diagcounts[i] for i in (1, 3, 4, 6, 7, 8, 10)) == 2: # compute function
        return 7 if sum(diagcounts[i] for i in (1, 4, 7)) == 1 else 8
    else: # do nothing
        return 10

@TABLE

neighborhood: von Neumann
symmetries: permute

var anyhead = (SH, WH, NH1, NH0)
var anyNTAA = (NH1, NH0, NT, NW)

# wireworld heads
(SH, ST), any; [0: (ST, SW)]
(WH, WT), any; [0: (WT, WW)]
# wireworld transitions
SW, <12 / (SH, NH1) / any - (SH, NH1)>; SH
SW, <2 / (WH, NH1) / any - (WH, NH1)>; SH
WW, <12 / (SH, NH1) / any - (SH, NH1)>; WH
WW, <1 / (WH, NH1) / any - (WH, NH1)>; WH


ousgbfioshfisghfoigsdfvigseiofgisegfisdfeh, wafyhwiawcfhosefh, wasyfcw9asi yfc.
DelibrateSyntaxError

@COLORS
000: B
FF0: SH
770: ST 
603: SW
FFF: WH
888: WT
222: WW
0F0: NH1
F00: NH0
777: NT
007: NW
