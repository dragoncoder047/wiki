@NUTSHELL Fusion

Fusion is a rule I devised that is a 'fusion' of many different wire-like rules. It steals properties from:
* Wireworld++ => tiny AND/XOR gates
* NoTimeAtAll => stagnating signals
* Digital => diagonal inputs, orthogonal outputs
* DECA => tiny AND/ANDNOT gates

States:

0: {Background} background
1: {StrongHead} strong head
2: {StrongTail} strong tail
3: {StrongWire} strong wire
4: {WeakHead} weak head
5: {WeakTail} weak tail
6: {WeakWire} weak wire
7: {NTAAHead1} NTAA head 1
8: {NTAAHead0} NTAA head 0
9: {NTAATail} NTAA tail
10: {NTAAWire} NTAA wire
--------------NTAA Table----------
0: blank
1: wire {w}
2: wire 0 {h0}
3: wire 1 {h1}
4: tail {t}

@TABLE
states: 5
neighborhood: vonNeumann

h = (h0, h1)
ht = (h, t)
wht = (w, ht)
wt = (w, t)

symmetries: permute

# NEVER put a head where there would be an adjacent tail
w, t, any ~ 3; w

symmetries: rotate4reflect

# Split at T
w, w, h, w, --wht; [2]

symmetries: permute

# Signals wait at intersections
w, w ~ 2, any ~ 2; w

# Sum=1 signal combination
w, h1, h1, any ~ 2; h0
w, h, h0, --h1 ~ 2; [1]

# Signals
w, h, --h ~ 3; [1]
h, --w ~ 4; t
t, --h ~ 4; w

-----------------

@TABLE

neighborhood: Moore
symmetries: permute

anyhead = (StrongHead, WeakHead, NTAAHead1, NTAAHead0)
anyNTAA = (NTAAHead1, NTAAHead0, NTAATail, NTAAWire)

# wireworld heads
(StrongHead, StrongTail), any; [0: (StrongTail, StrongWire)]
(WeakHead, WeakTail), any; [0: (WeakTail, WeakWire)]
# wireworld transitions
StrongWire, <12 / (StrongHead, NTAAHead1) / any - (StrongHead, NTAAHead1)>; StrongHead
StrongWire, <2 / (WeakHead, NTAAHead1) / any - (WeakHead, NTAAHead1)>; StrongHead
WeakWire, <12 / (StrongHead, NTAAHead1) / any - (StrongHead, NTAAHead1)>; WeakHead
WeakWire, <1 / (WeakHead, NTAAHead1) / any - (WeakHead, NTAAHead1)>; WeakHead

# NoTomeAtAll
symmetries: rotate4reflect
NTAAWire, N (NTAAHead0, NTAAHead1); NTAAWire # A wire with an adjacent head never turns to a head
(NTAAHead0, NTAAHead1), N --NTAAWire, E --NTAAWiree, S --NTAAWire, W --NTAAWire; NTAATail # A head only becomes tail if there is no wire
notNTAAHead = --(NTAAHead0, NTAAHead1)
NTAATail, N notNTAAHead, E notNTAAHead, S notNTAAHead, W notNTAAHead; NTAAWire # A tail only becomes wire if there is no head

# use NTAA heads as DECA red/green blocker states
notNTAA = any - anyNTAA
(NTAAHead0, NTAAHead1), N (StrongHead, StrongTail, WeakHead), E notNTAAHead, S notNTAAHead, W notNTAAHead; [0: (NTAAHead1, NTAAHead0)] # toggle when next to strong head, strong tail, or weak head and no NTAA neighbors

# NTAA XOR/Onehot gates
symmetries: rotate4reflect
NTAAWire, N (NTAAHead1, NTAAHead0), E NTAAWire, S [N], W (Background, NTAAWire); [W: (NTAAHead0, NTAAWire)]
NTAAWire, N (NTAAHead1, NTAAHead0), E NTAAWire, S [N: (NTAAHead0, NTAAHead1)], W (Background, NTAAWire); [W: (NTAAHead1, NTAAWire)]
symmetries: permute
NTAAWire, NTAAWire ~ 2, anyNTAA ~ 2, NTAAWire
NTAAWire, NTAAHead1, NTAAHead0 ~ 2, NTAAWire; NTAAHead1
NTAAWire, (NTAAHead0, NTAAHead1) ~ 3, NTAAWire, NTAAHead0

# activate when Wireworld++heads
NTAAWire, (anyhead - anyNTAA) ~ 1; NTAAHead0
NTAAWire, (anyhead - anyNTAA) ~ 2; NTAAHead1 


@COLORS

000: Background
FF0: StrongHead
770: StrongTail 
603: StrongWire
FFF: WeakHead
888: WeakTail
222: WeakWire
0F0: NTAAHead1
F00: NTAAHead0
777: NTAATail
007: NTAAWire
