@NUTSHELL Fusion

Fusion is a rule I devised that is a 'fusion' of many different wire-like rules. It steals properties from:
* Wireworld++ => tiny AND/XOR gates
* NoTimeAtAll => stagnating signals
* Digital => diagonal inputs, orthogonal outputs
* DECA => tiny AND/ANDNOT gates

States:

0: {Background} background
1: {StrongHead} strong head
2: {StrongTail} strong tail
3: {StrongWire} strong wire
4: {WeakHead} weak head
5: {WeakTail} weak tail
6: {WeakWire} weak wire
7: {NTAAHead1} NTAA head 1
8: {NTAAHead0} NTAA head 0
9: {NTAATail} NTAA tail
10: {NTAAWire} NTAA wire


@TABLE
neighborhood: Moore
anyNTAAHead = (NTAAHead0, NTAAHead1)
anyhead = (StrongHead, WeakHead, anyNTAAHead)
anyNTAA = (anyNTAAHead, NTAATail, NTAAWire)

# --------------NTAA--------------
# 0: blank
# 1: wire {w}
# 2: wire 0 {h0}
# 3: wire 1 {h1}
# 4: tail {t}

# h = (h0, h1)
# ht = (h, t)
# wht = (w, ht)
# wt = (w, t)

symmetries: nutshell.AlternatingPermute

# NEVER put a head where there would be an adjacent tail
# w, t, any ~ 3; w
NTAAWire, N NTAATail; NTAAWire

symmetries: rotate4reflect

# Split at T
# w, w, h, w, --wht; [2]
NTAAWire, N NTAAWire, E anyNTAAHead, S NTAAWire, W --anyNTAA; [E]

symmetries: nutshell.AlternatingPermute

# Signals wait at intersections
# w, w ~ 2, any ~ 2; w
NTAAWire, N NTAAWire, E NTAAWire; NTAAWire

# Sum=1 signal combination
# w, h1, h1, any ~ 2; h0
NTAAWire, N NTAAHead1, E NTAAHead1; NTAAHead0
# w, h, h0, --h1 ~ 2; [1]
NTAAWire, N anyNTAAHead, E NTAAHead0, S --NTAAHead1, W --NTAAHead1; [N]

# Signals
# w, h, --h ~ 3; [1]
NTAAWire, N anyNTAAHead, E --anyNTAAHead, S --anyNTAAHead, W --anyNTAAHead; [N]
# h, --w ~ 4; t
anyNTAAHead, N --NTAAWire, E --NTAAWire, S --NTAAWire, W --NTAAWire; NTAATail
# t, --h ~ 4; w
NTAATail, N --anyNTAAHead, E --anyNTAAHead, S --anyNTAAHead, W --anyNTAAHead; NTAAWire

# -----------------Wireworld++-----------------

symmetries: permute

# wireworld heads go immediately to tail
(StrongHead, StrongTail), any; [0: (StrongTail, StrongWire)]
(WeakHead, WeakTail), any; [0: (WeakTail, WeakWire)]
# wireworld++ transitions
StrongWire, <12 / (StrongHead, NTAAHead1) / any - (StrongHead, NTAAHead1)>; StrongHead
StrongWire, <2 / (WeakHead, NTAAHead1) / any - (WeakHead, NTAAHead1)>; StrongHead
WeakWire, <12 / (StrongHead, NTAAHead1) / any - (StrongHead, NTAAHead1)>; WeakHead
WeakWire, <1 / (WeakHead, NTAAHead1) / any - (WeakHead, NTAAHead1)>; WeakHead

# --------------DECA---------------

symmetries: rotate4reflect
# blocked by adjacent NTAA head1
(WeakWire, StrongWire), N Background, E (WeakWire, StrongWire), S NTAAHead1, W anyhead; [0]

# use NTAA heads as DECA red/green blocker states
symmetries: permute
(NTAAWire, NTAATail), N --anyNTAA, E --anyNTAA, S --anyNTAA, W --anyNTAA; NTAAHead0
symmetries: rotate4reflect
(NTAAHead0, NTAAHead1), N (StrongHead, StrongTail, WeakHead), E notNTAAHead, S notNTAAHead, W notNTAAHead; [0: (NTAAHead1, NTAAHead0)] # toggle when next to strong head, strong tail, or weak head and no NTAA neighbors

# ---------------some crossover------------

# activate when Wireworld++heads
NTAAWire, (anyhead - anyNTAA) ~ 1, any; NTAAHead0
NTAAWire, (anyhead - anyNTAA) ~ 2, any; NTAAHead1

@COLORS

000: Background
FF0: StrongHead
770: StrongTail 
603: StrongWire
FFF: WeakHead
888: WeakTail
222: WeakWire
0F0: NTAAHead1
F00: NTAAHead0
777: NTAATail
007: NTAAWire
